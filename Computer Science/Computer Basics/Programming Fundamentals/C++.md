## 数据类型

### 变量

- 整数类型：基本整数int；有符号整数signed；无符号整数unsigned；短整数short；长整数long；长长整数long long
- 浮点数类型：单精度浮点数float；双精度浮点数double；扩展精度浮点数long double
- 字符类型：char，容纳单个字符，实质储存字符的ascii码
- 布尔类型：true or false

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzibch7ae2j214u0ksn16.jpg" alt="image-20220215113644831" style="zoom:50%;" />

### 常量

- 整数常量：文字形式出现的整数
- 浮点数常量：文字形式出现的浮点数
- 字符常量：单括号引用的字符
- 符号常量：const float PI=3.14

### 自定义类型

- 定义新类型：typedef double Area, Volume; using Area = double
- 枚举类型：enum Weekday {SUN, MON, TUE, WED, THU, FRI, SAT}
- auto类型：编译器通过初始值推断变量类型 auto val = val1 + val2
- Decltype：定义一个变量与另一个变量类型相同 decltype(i) j = 2

## 运算

- 算数运算：先乘除，后加减，同级从左到右
- 赋值运算：将值赋给变量
- 逗号运算：a=3\*5,a\*4 先求解表达式1，再求解表达式2，结果为表达式2的值
- 关系运算：比大小，结果为bool
- 逻辑运算：!(非) &&(与，表达式1为假，不求解表达式2) ||(或，表达式1为真，不求解表达式2)
- 条件运算符：x=a>b ? a:b
- 位运算：按位与(&) 按位或(|) 按位异或(^) 取反(~) 移位(<< >>)

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzibcja10uj213c0ssadg.jpg" alt="image-20220215115029551" style="zoom:50%;" />

## 输入输出

- 在 C++中，将数据从一个对象到另一个对象的流动抽象为“流”。流在使用前要被建 立，使用后要被删除。
- 数据的输入与输出是通过 I/O 流来实现的，cin 和 cout 是预定义的流类对象。cin 用 来处理标准输入，即键盘输入。cout 用来处理标准输出，即屏幕输出。
- 从流中获取数据的操作称为提取操作，向流中添加数据的操作称为插入操作。

## 程序结构

- 顺序结构：程序从上到下执行
- 选择结构：if条件语句；switch case语句
- 循环结构：while do-while for break跳出循环 continue继续下一次循环

## 函数

### 基础

- 函数:定义好的、可重用的功能模块
- 定义函数:将一个模块的算法用 C++描述出来 
- 函数名:功能模块的名字 
- 函数的参数:计算所需要的数据和条件 
- 函数的返回值:需要返回的计算结果

### 参数传递

- 在函数被调用时才分配形参的存储单元
- 实参可以是常量、变量或表达式；实参类型必须与形参相符
- 值传递是传递参数值，即单向传递
- 引用传递可以实现双向传递
- 常引用作参数可以保障实参数据的安全

### 特殊函数

- 内联函数：声明时使用inline，编译时在调用处进行替换
- constexpr函数：constexpr 修饰的函数在其所有参数都是 constexpr 时，一定返回 constexpr
- 默认参数函数：预先设置默认的参数值，实参与形参从左到右结合，默认参数值必须在参数列表最右
- 函数重载：同名函数，形参个数不同或者类型不同，编译程序假根据实参形参类型和个数匹配选择调用

## 类与对象

```c++
class Temple
{
  	public: 公有成员
  	private: 私有成员
  	protected: 保护成员
}
```

- 公有类型成员：在关键字public后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数
- 私有类型成员：在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问
- 保护类型成员：与private类似，其差别表现在继承与派生时对派生类的影响不同

### 成员函数

- 在类中说明函数原型
- 可以在类外给出函数体实现，并在函数名前使用类名加以限定
- 也可以直接在类中给出函数体，形成内联成员函数
- 允许声明重载函数和带默认参数值的函数

### 构造函数

- 构造函数：在对象被创建时使用特定的值构造对象，将对象初始化为一个特定的初始状态。函数名与类名相同；不能定义返回值类型，也不能有return语句；可以有形式参数，也可以没有形式参数；可以是内联函数；如果程序中未定义构造函数，编译器将在需要时自动生成一个默认构造函数，无参数，默认方式初始化
- 委托构造函数：类中往往有多个构造函数，只是参数表和初始化列表不同，其初始化算法都是相同的，这时，为了避免代码重复，可以使用委托构造函数
- 复制构造函数：形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。程序未定义复制构造函数，则自动生成一个隐含的复制构造函数
- 析构函数： 完成对象被删除前的一些清理工作。在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。如果程序中未声明析构函数，编译器将自动产生一个默认的析构函数，其函数体为空。

### 类的组合

类中的成员是另一个类的对象。可以在已有抽象的基础上实现更复杂的抽象

组合类的构造函数不仅要负责对本类中的基本类型成员数据初始化，也要对对象成员初始化

## 数据保护与共享

### 作用域

作用域是一个标识符在程序中有效的区域

- 函数原型作用域：函数原型中的参数
- 局部作用域(块作用域)：函数的形参、在块中声明的标识符，作用域自声明处起，限于块中
- 类作用域：类的成员有类作用域，范围包括类体和非内联函数的函数体
- 文件作用域：作用域开始于声明点，结束于文件尾
- 命名空间作用域

### 可见性

- 可见性表示从内层作用域向外层作用域“看”时能看见什么。如果标识在某处可见，就可以在该处引用此标识符。
- 如果某个标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在内层可见
- 对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层作用域的标识符在内层不可见

### 生存期

- 静态生存期：生存期与程序的运行期相同，在文件作用域中声明的对象有静态生存期；在函数内部声明的静态对象，要加static
- 动态生存期：块作用域中声明的，没有用static修饰的对象，生存期结束于块结束时

### 类

类的静态成员

- 静态数据成员：类的静态数据成员用static声明，为该类所有对象共享，具有静态生存期，在类外定义和初始化

- 静态函数成员：静态成员函数用于处理该类的静态数据成员，访问非静态成员时，需要通过对象来访问

类的友元

- 友元是C++提供的一种破坏数据封装和数据隐藏的机制。通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息
- 友元函数是在类声明中由关键字friend修饰说明的非成员函数，在它的函数体中能 够通过对象名访问 private 和 protected成员
- 友元类：若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员。将友元类名在另一个类中使用friend说明；类的友元是单项的

### 数据保护

- 常对象：用const修饰的对象，初始化后不能被更新
- 常成员：用const修饰的函数或者数据，常成员函数不更新对象的数据成员，常对象只能调用常成员函数
- 常引用：被引用的对象不能更新，使用常引用做形参，不会意外改变实参
- 常指针：指向常量的指针；与指针常量不同

### 文件结构

- 类声明文件(.h文件)
- 类实现文件(.cpp文件)
- 类的使用文件(main()所在的.cpp文件)

## 数据结构

### 数组

- 数组是具有一定顺序关系的若干相同类型变量的集合体，组成数组的变量称为该数组的元素

- 使用数组时先声明，后使用

- 数组元素在内存中顺次存放，它们的地址是连续的。元素间物理地址上的相邻，对应着逻辑次序上的相邻

- 数组名作参数，形、实参数都是数组名

### 指针

- 指针指内存地址，用于间接访问内存单元
- 指针可以进行算数运算，代表指向下一个或者前一个完整数据的起始
- 指针可以指向数组元素，通过指针的算数运算完成数组遍历
- 指针可以用作函数参数，完成数据的双向传递，也可作为函数的返回值，但返回值应在主函数中有定义
- 指针可以指向对象，对象中的this指针指向自己
- 指针可以指向动态内存，但使用结束后需要delete释放内存，否则会内存泄漏

### 字符串

- C风格的字符串用字符数组表示，最终以'\0'结尾
- C++使用string类来表示字符串，封装了字符数组，可以判断字符长短，相等
- getline(cin, s)可以用于整行字符串的输入

## 类的继承

### 单继承

保持已有类的特性而构造新类的过程称为继承，在已有类的基础上新增自己的特性而产生新类的过程称为派生

- 公有继承：基类的public和protected成员在派生类中保持不变，基类的private成员不可直接访问，成员函数可以访问基类public和protected，通过派生类对象只能访问public成员；公有派生类对象可以被当作基类的对象使用
- 私有继承：基类的public和protected成员以private身份出现在派生类中，private成员不可直接访问，成员函数可以访问基类public和protected，通过派生类对象不能直接访问任何基类成员
- 保护继承：基类的public和protected成员以protected身份出现在派生类中，private成员不可直接访问，成员函数可以访问基类public和protected，通过派生类对象不能直接访问任何基类成员

### 构造与析构

- 默认情况下，派生类对象不继承基类构造函数，需要定义自己的构造函数；新定义的构造函数需要初始化派生类新增成员，同时调用基类构造函数给基类成员进行初始化

- 构造函数调用时，首先按照被继承时声明的顺序调用基类的构造函数，然后对初始化成员列表中的成员进行初始化，最后执行派生类构造函数体中的内容
- 派生类的复制构造函数调用时，先调用基类的复制构造函数，再为派生类的新增成员执行复制

- 基类析构函数不被继承，派生类如果需要，要自行声明析构函数。声明方法与无继承关系时类的析构函数相同。不需要显式地调用基类的析构函数，系统会自动隐式调用。 先执行派生类析构函数的函数体，再调用基类的析构函数。

### 虚基类

- 当派生类从多个基类派生，而这些基类又共同基类，则在访问此共同基类中 的成员时，将产生冗余，并有可能因冗余带来不一致性
- 在第一级继承时将共同基类设计为虚基类，以virtual说明基类继承方式，为最远的派生类提供唯一基类成员，而不重复产生多次复制
- 虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化，其他类对虚基类构造函数的调用被忽略

## 多态

### 运算符重载

- 运算符重载为类的成员函数：针对新类型的需要，对原有运算符进行适当改造，oprd1 B oprd2相当于oprd1.operator B(oprd2)
- 运算符重载为非成员函数：函数的形参从左到右代表各操作数，参数个数等于操作数个数，操作私有成员时，声明为类的友元

### 虚函数

- 当使用指针或对基类的引用来引用派生的类对象时，可以为该对象调用**虚函数**并执行该**函数**的派生类版本
- 虚函数必须是非静态的成员函数，虚函数经过派生之后，就可以实现运行过程中的多态
- 虚函数使用virtual关键字声明，虚函数声明只能出现在类定义中的函数原型声明中，而不能在成员函数实现的时候
- 派生类可以不显式地用virtual声明虚函数，这时系统根据函数名称，参数，返回值三个方面检查确定是否为虚函数
- 将析构函数声明为虚函数，可以通过基类指针删除派生类对象

### 抽象类

- 纯虚函数是一个在基类中声明的虚函数，它在该基类中没有定义具体的操作内容， 要求各派生类根据实际需要定义自己的版本，使用virtual关键字说明，virtual func() = 0
- 带有纯虚函数的类称为抽象类，为抽象和设计的目的而声明，不能生成对象

## 标准模版库

- 容器：顺序容器（数组、向量、列表等），关联容器（集合、映射、多重映射等）
- 迭代器：泛化的指针，提供了顺序访问容器中每个元素的方法，通过++ --等运算符访问元素
- 函数对象：行为类似函数的对象
- 算法：排序算法，置换算法等

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzibc8iwi2j20uk0bejsd.jpg" alt="image-20220218151647343" style="zoom:50%;" />

## 流类库

### 输出流

- ostream: 输出，std::cout为标准输出函数，转化数据为字符串并输出至控制台
- ofstream: 文件输出，需要预先初始化ofstream，转化所有数据为字符串并输出至文件流中
- ostringstream: 字符串输出，数据转化为字符串

### 输入流

- istream: 适合顺序文本输入，std::cin为标准输入函数，从控制台输入，getline可以实现按行输入，可以转化输入字符串为特定类型
- ifstream: 磁盘文件输入，预先初始化ifstrem，转化数据为字符串并输出至文件流
- istringstream: 字符串输入，任意输入数据存储为字符串

## 异常处理

![image-20220218153235618](https://tva1.sinaimg.cn/large/e6c9d24egy1gzibsph3xvj21k00ogq9l.jpg)