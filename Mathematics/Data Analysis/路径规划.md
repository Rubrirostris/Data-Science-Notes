## \图搜索算法

• DFS深度优先搜索：通过栈来实现

• BFS广度优先搜索：通过队列来实现

## 最短路径算法

### Floyd算法

每次循环中，对比从i到j以及从i到k和从k到j两条路径之和的大小，时间复杂度$O(n^3)$，空间复杂度$O(n^2)$
$$
a[i][j]=min(a[i][k]+a[k][j], a[i][j])
$$

### Dijkstra算法

单向Dijkstra算法可以计算单源最短路径问题，使用堆优化的dijkstra算法时间复杂度为O(nlogn)，空间复杂度O(n)

• 维护两个集合s和t，s代表计算过最小距离的点，t代表未计算过最小距离的点；维护一个数组dist记录所有点到起点的最小距离，初始化为正无穷；维护一个小顶堆heap，记录与起点的距离

• 将起点放入集合s，剩余点放入集合t，并将所有与起点相连的点的距离放入小顶堆，pop出顶端元素并将距离写入数组dist，该点进入s

• 计算集合t中所有点与新入集合s的相连的点的距离并插入堆，pop出顶端元素并计算起点到该点的最小距离，并将该点纳入s

• 反复迭代，直到集合t中没有点为止

双向Dijkstra主要用于解决单个起点和单个终点的最短路径问题，相比于普通的Dijkstra算法，速度约快一倍

• 分别从起点$s$和终点$t$开始计算到达其他点的最短路，维护两个集合$S(i)$和$T(i)$，代表$s$到$i$的最短路径和$t$到$i$的最短路径

• 若$S(i)$和$T(i)$都被访问，那么这就是可行路径，取距离相加最小即为最短路径

• 算法在$Min(S(i)+T(i))\le Min(S(i))+Min(T(i))$时终止，所求为答案

### Bellman-Ford算法

Dijkstra算法限于处理无负权值边的单源最短路径问题，BF算法可以处理负权边的情况，时间复杂度O(ne)，空间复杂度O(n)

• 初始化与起点距离的数组，所有距离设置为正无穷

• 外层循环n-2次，因为两个顶点的最短距离最多经过n-2个节点

• 内层对所有边做循环，如果边的出节点距离小于边入节点距离加边的权重，那么更新边的出节点距离

• 再对所有边做一次循环，如果出现距离更新操作，则原始图中有环

### SPFA最短路径快速算法

SPFA(Shortest Path Faster Algorithm)单源最短路径算法，时间复杂度O(kE)，k为常数，在稀疏图中的时间消耗小于Dijkstra

从起点开始采用BFS+FIFO队列进行搜索，搜索到某一个点i后，遍历i的所有边进行更新

• 维护一个最短距离数组，初始化为正无穷；维护一个FIFO队列，并将起点入队，数组距离置为0

• 队首x出队，遍历所有以队首为起点的有向边(x,i)，若dis[x]+w(x,i)<dis[i]，则更新dis[i]

• 如果点i不在队列中，则i入队

• 若队列为空，跳出循环；否则执行第一步

### CH算法

Dijkstra算法在地图导航问题中速度较慢，CH算法是一种查找图形中最短路径的加速算法

CH算法依赖在预处理阶段创建的“shortcuts”来减少搜索空间，即CH查询时必须查看的顶点数，从而提高搜索效率。我们通过一次“收缩”一个节点来预处理图形。为了执行收缩，我们计算出节点之间的每条最短路径，并为其插入“shortcuts”，然后将节点标记为已处理

## 路线引擎

整个路线引擎类似于一个推荐系统，由路线召回和路线排序部分组成。路线召回部分使用寻路算法生成150条路线，路线排序分为粗排和精排，粗排部分对150条路线排序产出10条路线，精排再对这10条路线排序产出3条路线，冒泡页展示3条路线

路线召回部分分为两个步骤，分别是子路网生成(Route-Planner)、多路线生成(Route-Restore)

### 子路网生成

1. 首先按照绑路策略进行绑路，之后对起终点的Link进行比例截取

2. 之后调用ch-compiler模块的_ch_based_multi_road函数进行子路网生成

   通过双向dijkstra算法寻找到起终点之间的一条最短路径

   在该路线的基础上通过松弛搜索条件：权重值和搜索深度，来扩展可搜索到的道路，直到搜索到指定数量的候选道路或者无路可搜

   将上述搜索到的所有的路线的Link去重后返回给route-planner模块作为子路网的主要构成部分

3. 在获得上述子路网之后，将起终点为中心，一定距离内的所有link都添加进去从而构成最终的子路网

### 多路线生成

多路线生成模块步骤是建立子图拓扑关系、起终点绑路、多路线搜索、路线transform

1. 建立子图拓扑关系：

   在获取子路网之后，去除子路网内部的black link, virtual link, walk street link, non through link. 然后再过滤掉单link交规。剩余的link作为可用的子路网进行下一步的操作

2. 起终点绑路：按照绑路策略进行绑路（一般是寻找起终点附近最近且夹角最小的link）

3. 多路线规划

   旧策略：

   • 利用双向Dijkstra，先获得一个最短路，用于BFS的剪枝

   • 对于起点和终点部分，得到link集合

   • 对于中间部分，BFS搜索

   新策略：分层设置途径点搜路

   • 利用双向Dijkstra找到一条最短路径

   • 在最短路径中找到核心元素：核心元素定义为连续link集合，且每个link出入度都为1

   • 将核心元素中的link设置为途径点，途径点设置为forbidden link重新搜路

   • 将途径点设置为起终点，与原始起终点组合，按上述方法搜路，直到符合路线生成数目为止

4. 路线修复

   对多路线进行去重、去除环形路、违反交规的路、修复不合理路线等

### 路线权值

在使用dijsktra等寻路算法时，每个link有相应权值，权值分为基础权值和实时权值，基础权值离线更新，实时权值根据路况信息实时更新

对于link有历史速度字段的，基础权值采用历史速度字段，对于没有历史速度字段的，采用道路等级等字段预测历史速度，权值的计算公式是link长度/速度

目前正在做权值优化，希望通过机器学习的方法来优化link权值，加入了link embedding等技术