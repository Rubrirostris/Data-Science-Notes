## 排序算法

### 插入排序

- Time complexity: $O(n^2)$
- Space complexity: $O(1)$

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        for i in range(1, len(nums)):
            key = nums[i]
            j = i - 1
            while j >= 0 and nums[j] > key:
                nums[j+1] = nums[j]
                j -= 1
            nums[j+1] = key
        return nums
```

###  冒泡排序

- Time complexity: $O(n^2)$
- Space complexity: $O(1)$

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        for i in range(1, len(nums)):
            for j in range(len(nums)-i):
                if nums[j] > nums[j+1]:
                    nums[j], nums[j+1] = nums[j+1], nums[j]
        return nums
```

### 选择排序

- Time complexity: $O(n^2)$
- Space complexity: $O(1)$

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            index, minimum = i, nums[i]
            for j in range(i, len(nums)):
                if nums[j] < minimum:
                    minimum = nums[j]
                    index = j
            nums[i], nums[index] = nums[index], nums[i]
        return nums
```

### 归并排序

- Time complexity: $O(nlogn)$
- Space complexity: $O(n)$

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        if len(nums) <= 1:
            return nums
        mi = len(nums)//2
        left = self.sortArray(nums[:mi])
        right = self.sortArray(nums[mi:])
        return self.merge(left, right)
    
    def merge(self, left, right):
        newnum = []
        i, j = 0, 0
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                newnum.append(left[i])
                i += 1
            else:
                newnum.append(right[j])
                j += 1
        if i < len(left):
            while i < len(left):
                newnum.append(left[i])
                i += 1
        if j < len(right):
            while j < len(right):
                newnum.append(right[j])
                j += 1
        return newnum
```

### 快速排序

- Time complexity: $O(nlogn)$
- Space complexity: $O(1)$

```python
# Inplace Algorithm
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        self.quicksort(nums, 0, len(nums)-1)
        return nums
        
    def quicksort(self, nums, lo, hi):
        if lo >= hi:
            return
        pivot_index = random.randint(lo, hi)
        mi = self.partition(nums, lo, hi, pivot_index)
        self.quicksort(nums, lo, mi-1)
        self.quicksort(nums, mi+1, hi)
        
    def partition(self, nums, lo, hi, pivot_index):
        nums[hi], nums[pivot_index] = nums[pivot_index], nums[hi]
        pivot = nums[hi]
        i, j = lo, lo
        while j < hi:
            if nums[j] <= pivot:
                nums[j], nums[i] = nums[i], nums[j]
                i += 1
            j += 1
        nums[hi], nums[i] = nums[i], nums[hi]
        return i
```

```python
# Inplace Algorithm
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        self.quickselect(nums, 0, len(nums)-1)
        return nums
        
    def quickselect(self, nums, lo, hi, k):
        if lo >= hi:
            return
        pivot_index = random.randint(lo, hi)
        mi = self.partition(nums, lo, hi, pivot_index)
        if mi == k:
            return nums[mi]
        elif mi > k:
            return self.quickselect(nums, lo, mi-1, k)
        else:
            return self.quickselect(nums, mi+1, hi, k)
        
    def partition(self, nums, lo, hi, pivot_index):
        nums[hi], nums[pivot_index] = nums[pivot_index], nums[hi]
        pivot = nums[hi]
        i, j = lo, lo
        while j < hi:
            if nums[j] <= pivot:
                nums[j], nums[i] = nums[i], nums[j]
                i += 1
            j += 1
        nums[hi], nums[i] = nums[i], nums[hi]
        return i
```



### 堆排序

- Time complexity: $O(nlogn)$
- Space complexity: $O(n)$

```python
import heapq
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        heapq.heapify(nums)
        newnums = []
        while nums:
            newnums.append(heapq.heappop(nums))
        return newnums
```

## 二分查找

```python
def binary_search(array) -> int:
    def condition(value) -> bool:
        pass

    left, right = min(search_space), max(search_space) # could be [0, n], [1, n] etc. Depends on problem
    while left < right:
        mid = left + (right - left) // 2
        if condition(mid):
            right = mid
        else:
            left = mid + 1
    return left
```





